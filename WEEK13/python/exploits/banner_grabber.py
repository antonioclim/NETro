#!/usr/bin/env python3
"""
================================================================================
Banner Grabber - Enumerare servicii prin analiza banner-urilor
================================================================================
S13 - IoT și Securitate în Rețele de Calculatoare

OBIECTIVE PEDAGOGICE:
1. Înțelegerea procesului de fingerprinting al serviciilor
2. Extragerea informațiilor din răspunsurile protocoalelor
3. Identificarea versiunilor software pentru evaluarea securității

UTILIZARE:
    python3 banner_grabber.py --target 10.0.13.12 --port 2121
    python3 banner_grabber.py --target 10.0.13.11 --port 80 --http
    python3 banner_grabber.py --target 10.0.13.11 --ports 21,22,80,443,8080
================================================================================
"""

from __future__ import annotations

import argparse
import json
import socket
import ssl
import sys
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional

# ==============================================================================
# CONSTANTE
# ==============================================================================

class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    CYAN = "\033[96m"
    RESET = "\033[0m"
    BOLD = "\033[1m"


# Probe pentru diferite protocoale
PROTOCOL_PROBES = {
    "generic": b"\r\n",
    "http": b"HEAD / HTTP/1.1\r\nHost: target\r\nConnection: close\r\n\r\n",
    "ftp": b"",  # FTP trimite banner automat
    "smtp": b"",  # SMTP trimite banner automat
    "ssh": b"",  # SSH trimite banner automat
    "mqtt": bytes([0x10, 0x0c, 0x00, 0x04, 0x4D, 0x51, 0x54, 0x54, 0x04, 0x00, 0x00, 0x3c, 0x00, 0x00]),
}


# ==============================================================================
# STRUCTURI DE DATE
# ==============================================================================

@dataclass
class BannerResult:
    """Rezultatul extragerii banner-ului."""
    host: str
    port: int
    protocol: str
    banner: Optional[str]
    headers: Dict[str, str]
    tls_info: Optional[Dict]
    raw_response: bytes
    success: bool
    error: Optional[str] = None


# ==============================================================================
# FUNCȚII DE GRABBING
# ==============================================================================

def grab_generic_banner(
    host: str,
    port: int,
    timeout: float = 3.0,
    probe: bytes = b"\r\n"
) -> BannerResult:
    """
    Extrage banner-ul generic de la un serviciu TCP.
    """
    result = BannerResult(
        host=host, port=port, protocol="unknown",
        banner=None, headers={}, tls_info=None,
        raw_response=b"", success=False
    )
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Pentru unele servicii, banner-ul vine automat
        # Pentru altele, trimitem un probe
        if probe:
            sock.sendall(probe)
        
        # Citim răspunsul
        response = b""
        try:
            while len(response) < 4096:
                chunk = sock.recv(1024)
                if not chunk:
                    break
                response += chunk
                # Dacă avem suficient pentru banner, ne oprim
                if b"\n" in response or len(response) > 512:
                    break
        except socket.timeout:
            pass
        
        sock.close()
        
        result.raw_response = response
        result.banner = response.decode("utf-8", errors="replace").strip()
        result.success = True
        
        # Detectăm protocolul din banner
        banner_lower = result.banner.lower()
        if "ssh" in banner_lower:
            result.protocol = "ssh"
        elif "ftp" in banner_lower or "220 " in banner_lower:
            result.protocol = "ftp"
        elif "smtp" in banner_lower or "220 " in banner_lower:
            result.protocol = "smtp"
        elif "http" in banner_lower:
            result.protocol = "http"
        elif "mqtt" in banner_lower or response.startswith(b"\x20"):
            result.protocol = "mqtt"
    
    except socket.timeout:
        result.error = "Connection timeout"
    except ConnectionRefusedError:
        result.error = "Connection refused"
    except Exception as e:
        result.error = str(e)
    
    return result


def grab_http_banner(
    host: str,
    port: int,
    timeout: float = 3.0,
    use_https: bool = False
) -> BannerResult:
    """
    Extrage informații HTTP/HTTPS detaliate.
    """
    result = BannerResult(
        host=host, port=port, protocol="https" if use_https else "http",
        banner=None, headers={}, tls_info=None,
        raw_response=b"", success=False
    )
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Wrap în SSL dacă HTTPS
        if use_https:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            sock = context.wrap_socket(sock, server_hostname=host)
            
            # Extragem info TLS
            cert = sock.getpeercert(binary_form=True)
            result.tls_info = {
                "version": sock.version(),
                "cipher": sock.cipher(),
            }
        
        # Trimitem cerere HTTP
        request = f"HEAD / HTTP/1.1\r\nHost: {host}\r\nConnection: close\r\nUser-Agent: S13-BannerGrabber/1.0\r\n\r\n"
        sock.sendall(request.encode())
        
        # Citim răspunsul
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
        
        sock.close()
        
        result.raw_response = response
        response_str = response.decode("utf-8", errors="replace")
        
        # Parsăm headerele
        lines = response_str.split("\r\n")
        if lines:
            result.banner = lines[0]  # Status line
            
            for line in lines[1:]:
                if ": " in line:
                    key, value = line.split(": ", 1)
                    result.headers[key.lower()] = value
        
        result.success = True
    
    except ssl.SSLError as e:
        result.error = f"SSL error: {e}"
    except socket.timeout:
        result.error = "Connection timeout"
    except ConnectionRefusedError:
        result.error = "Connection refused"
    except Exception as e:
        result.error = str(e)
    
    return result


def grab_banner(
    host: str,
    port: int,
    timeout: float = 3.0,
    force_http: bool = False
) -> BannerResult:
    """
    Funcție wrapper care alege metoda potrivită de grabbing.
    """
    # Detectăm protocolul bazat pe port
    if force_http or port in [80, 8080, 8000, 8888]:
        return grab_http_banner(host, port, timeout, use_https=False)
    elif port in [443, 8443]:
        return grab_http_banner(host, port, timeout, use_https=True)
    else:
        return grab_generic_banner(host, port, timeout)


def print_result(result: BannerResult) -> None:
    """Afișează rezultatul în format frumos."""
    print(f"\n{Colors.CYAN}{'─'*60}{Colors.RESET}")
    print(f"{Colors.BOLD}  {result.host}:{result.port} ({result.protocol}){Colors.RESET}")
    print(f"{Colors.CYAN}{'─'*60}{Colors.RESET}")
    
    if result.success:
        print(f"  {Colors.GREEN}[✓] Banner obținut{Colors.RESET}")
        
        if result.banner:
            print(f"\n  {Colors.YELLOW}Banner:{Colors.RESET}")
            for line in result.banner.split("\n")[:5]:
                print(f"    {line[:70]}")
        
        if result.headers:
            print(f"\n  {Colors.YELLOW}Headers relevante:{Colors.RESET}")
            for key in ["server", "x-powered-by", "content-type", "www-authenticate"]:
                if key in result.headers:
                    print(f"    {key}: {result.headers[key]}")
        
        if result.tls_info:
            print(f"\n  {Colors.YELLOW}TLS Info:{Colors.RESET}")
            print(f"    Version: {result.tls_info.get('version')}")
            print(f"    Cipher: {result.tls_info.get('cipher')}")
    
    else:
        print(f"  {Colors.RED}[✗] Eroare: {result.error}{Colors.RESET}")


# ==============================================================================
# MAIN
# ==============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Banner grabber pentru laborator S13"
    )
    
    parser.add_argument("--target", required=True, help="Adresa IP țintă")
    parser.add_argument("--port", type=int, help="Port unic")
    parser.add_argument("--ports", help="Lista de porturi (ex: 21,22,80,443)")
    parser.add_argument("--http", action="store_true", help="Forțează mod HTTP")
    parser.add_argument("--timeout", type=float, default=3.0, help="Timeout (default: 3s)")
    parser.add_argument("--json-out", help="Export JSON")
    
    args = parser.parse_args()
    
    if not args.port and not args.ports:
        print("Specifică --port sau --ports")
        sys.exit(1)
    
    # Banner
    print(f"\n{Colors.CYAN}{'='*60}")
    print("  S13 - Banner Grabber")
    print(f"{'='*60}{Colors.RESET}")
    
    # Parsăm porturile
    ports = []
    if args.port:
        ports.append(args.port)
    if args.ports:
        ports.extend([int(p.strip()) for p in args.ports.split(",")])
    
    # Executăm grabbing
    results = []
    for port in ports:
        result = grab_banner(args.target, port, args.timeout, args.http)
        results.append(result)
        print_result(result)
    
    # Export JSON
    if args.json_out:
        data = {
            "scan_time": datetime.now().isoformat(),
            "target": args.target,
            "results": [
                {
                    "port": r.port,
                    "protocol": r.protocol,
                    "banner": r.banner,
                    "headers": r.headers,
                    "success": r.success,
                    "error": r.error
                }
                for r in results
            ]
        }
        with open(args.json_out, "w") as f:
            json.dump(data, f, indent=2)
        print(f"\n{Colors.GREEN}[✓] Export: {args.json_out}{Colors.RESET}")
    
    print()


if __name__ == "__main__":
    main()
