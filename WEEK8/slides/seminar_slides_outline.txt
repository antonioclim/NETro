================================================================================
OUTLINE SLIDE-URI SEMINAR 8 - IMPLEMENTARE SERVER HTTP & REVERSE PROXY
================================================================================
Disciplina: Rețele de Calculatoare
Săptămâna: 8 | Anul 3, Semestrul 2 | Informatică Economică ASE București
Tema: "Servicii Internet: implementarea unui server HTTP. Reverse proxies."
Export recomandat: PowerPoint / reveal.js / Google Slides
================================================================================

──────────────────────────────────────────────────────────────────────────────
SLIDE 1: TITLU SEMINAR
──────────────────────────────────────────────────────────────────────────────
• Seminar 8: Server HTTP & Reverse Proxy
• Dezvoltare asistată de cod
• [Logo universitate] [Logo curs]
• Data: [auto-fill]

──────────────────────────────────────────────────────────────────────────────
SLIDE 2: OBIECTIVE PRACTICE
──────────────────────────────────────────────────────────────────────────────
• La finalul seminarului veți putea:
  1. Implementa un server HTTP minimal în Python
  2. Înțelege parsarea request-urilor HTTP
  3. Genera răspunsuri HTTP corecte
  4. Construi un reverse proxy cu load balancing
  5. Analiza traficul TCP cu tshark
• Toate cu cod funcțional, testat, reproducibil

──────────────────────────────────────────────────────────────────────────────
SLIDE 3: PRERECHIZITE ȘI SETUP
──────────────────────────────────────────────────────────────────────────────
• Cunoștințe necesare:
  - Socket programming (Seminar 2-3)
  - Protocolul TCP (Curs 8)
  - Baze Linux/Bash
• Setup mediu:
  cd starterkit_s8
  make verify          # validare dependențe
  make setup           # pregătire mediu
• Fișiere importante:
  - python/demos/demo_http_server.py
  - python/demos/demo_reverse_proxy.py
  - python/utils/net_utils.py

──────────────────────────────────────────────────────────────────────────────
SLIDE 4: ARHITECTURA GENERALĂ
──────────────────────────────────────────────────────────────────────────────
• Diagrama sistem:
  ┌─────────────┐     ┌─────────────────┐     ┌─────────────┐
  │   Client    │────▶│  Reverse Proxy  │────▶│  Backend A  │
  │  (browser)  │     │    (port 8080)  │──┬──│  (port 8081)│
  └─────────────┘     └─────────────────┘  │  └─────────────┘
                             │             │  ┌─────────────┐
                             ▼             └──│  Backend B  │
                      ┌─────────────┐         │  (port 8082)│
                      │   tshark    │         └─────────────┘
                      │  (captură)  │
                      └─────────────┘
• Componentele vor fi implementate pas cu pas

──────────────────────────────────────────────────────────────────────────────
SLIDE 5: DEMO 1 - HTTP SERVER SIMPLU
──────────────────────────────────────────────────────────────────────────────
• Pornire server:
  python3 python/demos/demo_http_server.py --port 8081 --docroot www/
• Test cu curl:
  curl -v http://localhost:8081/
  curl http://localhost:8081/hello.txt
  curl http://localhost:8081/nonexistent.html  # 404
• Observăm în terminal: log-uri cu timestamp, method, path, status

──────────────────────────────────────────────────────────────────────────────
SLIDE 6: STRUCTURA HTTP REQUEST
──────────────────────────────────────────────────────────────────────────────
• Format cerere HTTP/1.1:
  ┌────────────────────────────────────────┐
  │ GET /index.html HTTP/1.1               │ ← Request Line
  │ Host: localhost:8081                   │ ← Headers
  │ User-Agent: curl/7.68.0                │
  │ Accept: */*                            │
  │                                        │ ← Linie goală (CRLF)
  │ [body dacă există]                     │
  └────────────────────────────────────────┘
• Separatoare: \r\n (CRLF) între linii

──────────────────────────────────────────────────────────────────────────────
SLIDE 7: PARSARE REQUEST - COD
──────────────────────────────────────────────────────────────────────────────
• Algoritmul:
  1. Citește până la \r\n\r\n (end of headers)
  2. Split pe primul \r\n → request line
  3. Split request line pe spații → method, path, version
  4. Restul liniilor sunt headers (key: value)
• Cod esențial:
  lines = request.split('\r\n')
  method, path, version = lines[0].split(' ', 2)
  headers = {}
  for line in lines[1:]:
      if ':' in line:
          key, value = line.split(':', 1)
          headers[key.strip().lower()] = value.strip()

──────────────────────────────────────────────────────────────────────────────
SLIDE 8: STRUCTURA HTTP RESPONSE
──────────────────────────────────────────────────────────────────────────────
• Format răspuns:
  ┌────────────────────────────────────────┐
  │ HTTP/1.1 200 OK                        │ ← Status Line
  │ Content-Type: text/html                │ ← Headers
  │ Content-Length: 1234                   │
  │ Server: SimpleHTTP/1.0                 │
  │                                        │ ← Linie goală
  │ <html>...</html>                       │ ← Body
  └────────────────────────────────────────┘
• Headers obligatorii: Content-Type, Content-Length

──────────────────────────────────────────────────────────────────────────────
SLIDE 9: GENERARE RESPONSE - COD
──────────────────────────────────────────────────────────────────────────────
• Construcția răspunsului:
  def build_response(status_code, status_text, headers, body):
      response = f"HTTP/1.1 {status_code} {status_text}\r\n"
      for key, value in headers.items():
          response += f"{key}: {value}\r\n"
      response += "\r\n"
      return response.encode('utf-8') + body
• Exemplu apel:
  headers = {"Content-Type": "text/html", "Content-Length": len(body)}
  return build_response(200, "OK", headers, body)

──────────────────────────────────────────────────────────────────────────────
SLIDE 10: SERVIREA FIȘIERELOR STATICE
──────────────────────────────────────────────────────────────────────────────
• Algoritmul:
  1. Extrage path din request
  2. Normalizează (elimină ../)  ← SECURITATE!
  3. Construiește cale completă: docroot + path
  4. Verifică existența fișierului
  5. Determină Content-Type din extensie
  6. Citește și returnează conținut
• MIME types:
  .html → text/html
  .css  → text/css
  .js   → application/javascript
  .json → application/json
  .png  → image/png

──────────────────────────────────────────────────────────────────────────────
SLIDE 11: SECURITATE - DIRECTORY TRAVERSAL
──────────────────────────────────────────────────────────────────────────────
• Atacul:
  GET /../../../etc/passwd HTTP/1.1
• Fără protecție → server expune sistem de fișiere!
• Soluție în Python:
  import os
  safe_path = os.path.normpath(path)
  full_path = os.path.join(docroot, safe_path)
  # Verifică că full_path începe cu docroot
  if not full_path.startswith(os.path.abspath(docroot)):
      return 403, "Forbidden"
• Testare: curl http://localhost:8081/../etc/passwd

──────────────────────────────────────────────────────────────────────────────
SLIDE 12: DEMO 2 - CAPTURĂ TSHARK
──────────────────────────────────────────────────────────────────────────────
• Într-un terminal:
  sudo tshark -i lo -f "tcp port 8081" -c 20
• În alt terminal:
  curl http://localhost:8081/
• Observăm:
  Pachet 1: SYN (client → server)
  Pachet 2: SYN-ACK (server → client)
  Pachet 3: ACK (client → server)
  Pachet 4: PSH,ACK - HTTP GET
  Pachet 5: PSH,ACK - HTTP Response
  Pachet 6-7: FIN,ACK - închidere

──────────────────────────────────────────────────────────────────────────────
SLIDE 13: INTERPRETARE CAPTURĂ
──────────────────────────────────────────────────────────────────────────────
• Tabel interpretare flags TCP:
  | Nr | Flags   | Direcție | Descriere               |
  |----|---------|----------|-------------------------|
  | 1  | SYN     | C→S      | Inițiere conexiune      |
  | 2  | SYN,ACK | S→C      | Acceptare conexiune     |
  | 3  | ACK     | C→S      | Confirmare, conn. ready |
  | 4  | PSH,ACK | C→S      | GET /index.html         |
  | 5  | PSH,ACK | S→C      | HTTP 200 OK + body      |
  | 6  | FIN,ACK | C→S      | Închidere client        |
  | 7  | FIN,ACK | S→C      | Închidere server        |

──────────────────────────────────────────────────────────────────────────────
SLIDE 14: REVERSE PROXY - CONCEPT
──────────────────────────────────────────────────────────────────────────────
• Rol:
  - Primește cereri de la clienți
  - Le distribuie către backend-uri
  - Agregă răspunsurile către client
• De ce e util:
  - Load balancing
  - High availability
  - SSL termination
  - Caching
  - Security (ascunde backend-uri)
• În practică: nginx, HAProxy, Traefik, AWS ALB

──────────────────────────────────────────────────────────────────────────────
SLIDE 15: DEMO 3 - REVERSE PROXY
──────────────────────────────────────────────────────────────────────────────
• Pas 1: Pornim 2 backend-uri
  python3 python/demos/demo_http_server.py --port 8081 --docroot www/
  python3 python/demos/demo_http_server.py --port 8082 --docroot www/
• Pas 2: Pornim reverse proxy
  python3 python/demos/demo_reverse_proxy.py \
      --port 8080 \
      --backends localhost:8081,localhost:8082
• Pas 3: Test
  for i in {1..6}; do curl http://localhost:8080/; done
• Observăm alternarea: A, B, A, B, A, B (Round Robin)

──────────────────────────────────────────────────────────────────────────────
SLIDE 16: IMPLEMENTARE ROUND ROBIN
──────────────────────────────────────────────────────────────────────────────
• Algoritm:
  class RoundRobinBalancer:
      def __init__(self, backends):
          self.backends = backends  # listă
          self.index = 0
      
      def next_backend(self):
          backend = self.backends[self.index]
          self.index = (self.index + 1) % len(self.backends)
          return backend
• Thread-safety: folosim threading.Lock() pentru index

──────────────────────────────────────────────────────────────────────────────
SLIDE 17: FORWARDING REQUEST
──────────────────────────────────────────────────────────────────────────────
• Pași:
  1. Primește request de la client
  2. Alege backend (round robin)
  3. Deschide conexiune TCP către backend
  4. Trimite request modificat (Host header)
  5. Primește răspuns de la backend
  6. Trimite răspuns către client original
• Modificări header:
  - Host: trebuie schimbat la adresa backend-ului
  - X-Forwarded-For: adaugă IP client original
  - X-Forwarded-Proto: http sau https

──────────────────────────────────────────────────────────────────────────────
SLIDE 18: HEADER FORWARDING - COD
──────────────────────────────────────────────────────────────────────────────
• Adăugare headers proxy:
  def add_proxy_headers(headers, client_ip):
      # Păstrează sau adaugă X-Forwarded-For
      xff = headers.get('x-forwarded-for', '')
      if xff:
          headers['x-forwarded-for'] = f"{xff}, {client_ip}"
      else:
          headers['x-forwarded-for'] = client_ip
      
      # Adaugă Via header
      headers['via'] = '1.1 proxy'
      return headers

──────────────────────────────────────────────────────────────────────────────
SLIDE 19: DEMO 4 - CAPTURĂ PROXY
──────────────────────────────────────────────────────────────────────────────
• Captură pe mai multe porturi:
  sudo tshark -i lo -f "tcp port 8080 or tcp port 8081 or tcp port 8082" -c 30
• Facem request:
  curl http://localhost:8080/
• Observăm DOUĂ conexiuni TCP:
  1. Client (port efemer) ↔ Proxy (8080)
  2. Proxy (port efemer) ↔ Backend (8081 sau 8082)
• Proxy-ul menține conexiuni separate!

──────────────────────────────────────────────────────────────────────────────
SLIDE 20: DEBUGGING FRECVENT
──────────────────────────────────────────────────────────────────────────────
• Tabel erori comune:
  | Simptom                | Cauză                    | Soluție                |
  |------------------------|--------------------------|------------------------|
  | Connection refused     | Server nu rulează        | Verifică cu ss -tuln   |
  | Address already in use | Port ocupat              | Schimbă port sau kill  |
  | 404 Not Found          | Fișier lipsă sau path    | Verifică docroot       |
  | Headers malformate     | CRLF lipsă               | Verifică \r\n          |
  | Timeout                | Server blocat în read    | Verifică dimensiune buf|

──────────────────────────────────────────────────────────────────────────────
SLIDE 21: COMENZI DEBUGGING
──────────────────────────────────────────────────────────────────────────────
• Verificare porturi:
  ss -tuln | grep 808          # ce porturi sunt deschise
  lsof -i :8080                # ce proces folosește portul
• Test conexiune:
  nc -vz localhost 8080        # test port
  curl -v http://localhost:8080/  # verbose output
• Oprire proces:
  kill $(lsof -t -i :8080)     # kill by port
• Log detailat:
  strace -f -e trace=network python3 server.py

──────────────────────────────────────────────────────────────────────────────
SLIDE 22: EXERCIȚIU 1 - COMPLETARE SERVER
──────────────────────────────────────────────────────────────────────────────
• Fișier: python/exercises/ex01_http_server.py
• Cerințe:
  1. Implementați funcția parse_request()
  2. Implementați funcția serve_file()
  3. Adăugați suport pentru HEAD method
• Test:
  python3 -m pytest tests/test_http_server.py -v
• Timp estimat: 30 minute

──────────────────────────────────────────────────────────────────────────────
SLIDE 23: EXERCIȚIU 2 - COMPLETARE PROXY
──────────────────────────────────────────────────────────────────────────────
• Fișier: python/exercises/ex02_reverse_proxy.py
• Cerințe:
  1. Implementați forward_request()
  2. Adăugați headers X-Forwarded-For și Via
  3. Implementați health check pentru backend-uri
• Test:
  python3 -m pytest tests/test_reverse_proxy.py -v
• Timp estimat: 30 minute

──────────────────────────────────────────────────────────────────────────────
SLIDE 24: EXERCIȚIU 3 - POST SUPPORT
──────────────────────────────────────────────────────────────────────────────
• Extindere server pentru POST:
  - Citire body (Content-Length header)
  - Parsare form data (application/x-www-form-urlencoded)
  - Returnare JSON cu datele primite
• Exemplu test:
  curl -X POST -d "name=John&age=25" http://localhost:8081/api/form
  → {"name": "John", "age": "25"}
• Timp estimat: 25 minute (exercițiu avansat)

──────────────────────────────────────────────────────────────────────────────
SLIDE 25: EXERCIȚIU 4 - RATE LIMITING
──────────────────────────────────────────────────────────────────────────────
• Implementare limitare cereri:
  - Maximum 10 cereri pe minut per IP
  - Returnează 429 Too Many Requests dacă depășit
  - Folosiți dicționar cu timestamp-uri
• Structură:
  rate_limits = {}  # ip -> [list of timestamps]
  def check_rate_limit(ip, max_requests=10, window=60):
      # TODO: implementare
• Timp estimat: 20 minute

──────────────────────────────────────────────────────────────────────────────
SLIDE 26: EXERCIȚIU CHALLENGE - CACHING PROXY
──────────────────────────────────────────────────────────────────────────────
• Implementare cache în proxy:
  - Cache pentru răspunsuri GET
  - TTL configurabil (ex: 60 secunde)
  - Respectă Cache-Control headers
• Bonus:
  - Statistici cache (hits vs misses)
  - Endpoint /cache/stats pentru monitorizare
  - Invalidare manuală /cache/clear
• Timp estimat: 45 minute (pentru studenți avansați)

──────────────────────────────────────────────────────────────────────────────
SLIDE 27: EXTENSII OPȚIONALE
──────────────────────────────────────────────────────────────────────────────
• TLS Support:
  - Generare certificate self-signed
  - Wrap socket cu ssl.wrap_socket()
  - Test cu curl --insecure
• Docker Compose:
  - 2 container-e backend (nginx)
  - 1 container proxy (Python)
  - Network internal pentru backend
• Mininet:
  - Topologie cu 3 host-uri
  - Delay artificial pentru observare RTT
  - Pierdere pachete configurabilă

──────────────────────────────────────────────────────────────────────────────
SLIDE 28: CONTRIBUȚIE PROIECT ECHIPĂ
──────────────────────────────────────────────────────────────────────────────
• Artefact livrabil săptămâna 8:
  1. Server HTTP funcțional (cod Python)
  2. Reverse proxy cu load balancing
  3. README cu instrucțiuni complete
  4. Captură tshark annotată (10+ pachete)
• Integrare:
  - Componenta "http-layer" în proiect
  - Pregătire pentru autentificare (Săpt. 9-10)
  - Bază pentru REST API (Săpt. 10)

──────────────────────────────────────────────────────────────────────────────
SLIDE 29: RECAPITULARE
──────────────────────────────────────────────────────────────────────────────
• Ce am învățat practic:
  ✓ Parsare HTTP request/response
  ✓ Server fișiere statice cu securitate
  ✓ Reverse proxy cu round robin
  ✓ Analiză trafic TCP cu tshark
  ✓ Debugging conexiuni de rețea
• Unde se folosește în industrie:
  - Backend development (Django, Flask, FastAPI)
  - DevOps (nginx, HAProxy, Traefik)
  - Cloud (ALB, API Gateway)

──────────────────────────────────────────────────────────────────────────────
SLIDE 30: RESURSE SUPLIMENTARE
──────────────────────────────────────────────────────────────────────────────
• Documentație:
  - RFC 7230-7235: HTTP/1.1 Semantics
  - https://developer.mozilla.org/en-US/docs/Web/HTTP
• Tools:
  - httpbin.org - testare HTTP
  - requestbin.com - inspect requests
• Practică:
  - Implementați un mini-framework web
  - Extindeți cu WebSockets
  - Adăugați middleware pattern

================================================================================
NOTE PENTRU CADRU DIDACTIC
================================================================================
• Timing: 2 ore (100 minute activitate, 20 minute pauză)
• Structură recomandată:
  - 0-15 min: Setup, recap, obiective
  - 15-40 min: Demo server HTTP + captură
  - 40-50 min: Pauză scurtă
  - 50-80 min: Demo reverse proxy + captură
  - 80-100 min: Exerciții ghidate
  - 100-120 min: Challenge + discuții
• Pregătire:
  - Verificați că toate demo-urile rulează
  - Pregătiți backup pentru conexiune internet
  - Aveți soluții pregătite pentru exerciții

================================================================================
© Revolvix&Hypotheticalandrei
================================================================================
